#######################################
#
# Processamento de ficheiros Python
#
#######################################

---------------------------------------------
Aceder a ficheiros a partir de c√≥digo Python
---------------------------------------------

Um dos problemas mais comuns no trabalho do programador √© PROCESSAR DADOS ARMAZENADOS
EM FICHEIROS, enquanto os ficheiros s√£o normalmente armazenados fisicamente utilizando 
dispositivos de armazenamento - discos r√≠gidos, √≥pticos, de rede ou solid-state.

√â f√°cil imaginar um programa que ordena 20 n√∫meros, e √© igualmente f√°cil imaginar o utilizador 
deste programa a introduzir estes vinte n√∫meros diretamente a partir do teclado.

√â muito mais dif√≠cil imaginar a mesma tarefa quando h√° 20.000 n√∫meros a serem ordenados, e n√£o h√° 
um √∫nico utilizador que seja capaz de introduzir estes n√∫meros sem cometer um erro.

√â muito mais f√°cil imaginar que estes n√∫meros s√£o armazenados no ficheiro de disco que √© lido pelo 
programa. O programa classifica os n√∫meros e n√£o os envia para o ecr√£, mas em vez disso cria um 
novo ficheiro e guarda a sequ√™ncia ordenada de n√∫meros l√°.

Se quisermos implementar um banco de dados simples, a √∫nica maneira de armazenar a informa√ß√£o 
entre execu√ß√µes do programa √© guard√°-la num ficheiro (ou ficheiros se a sua base de dados for mais complexa).

Em princ√≠pio, qualquer problema de programa√ß√£o n√£o simples depende do uso de ficheiros, quer 
processe imagens (armazenadas em ficheiros), multiplique matrizes (armazenadas em ficheiros) ou 
calcule sal√°rios e impostos (leitura de dados armazenados em ficheiros).

Pode perguntar-se porque esper√°mos at√© agora para lhe mostrar estas quest√µes.

A resposta √© muito simples - a forma do Python de aceder e processar ficheiros √© implementada 
usando um conjunto consistente de objetos. N√£o h√° melhor momento para falar sobre o assunto.



--------------------
Nomes de ficheiro
--------------------

Diferentes sistemas operativos podem tratar os ficheiros de diferentes formas. Por exemplo, o 
Windows utiliza uma conven√ß√£o de nomes diferente da adotada nos sistemas Unix/Linux.

Se utilizarmos a no√ß√£o de um nome de ficheiro can√≥nico (um nome que define de forma √∫nica a 
localiza√ß√£o do ficheiro independentemente do seu n√≠vel na √°rvore de diretoria) podemos perceber 
que estes nomes t√™m um aspeto diferente no Windows e no Unix/Linux:

    Exemplo no Windows:

      C:/directory/file


    Exemplo no Linux:

      /directory/files


Como pode ver, os sistemas derivados de Unix/Linux n√£o utilizam a letra da unidade de disco (por 
exemplo, C:) e todos os diretorios crescem a partir de um diretorio raiz chamado /, enquanto 
os sistemas Windows reconhecem o diretorio raiz como \.

Al√©m disso, os nomes dos ficheiros do sistema Unix/Linux s√£o sens√≠veis a mai√∫sculas e 
min√∫sculas. Os sistemas Windows armazenam a mai√∫scula ou min√∫scula das letras utilizadas no nome do ficheiro, mas n√£o distinguem de todo se s√£o de facto mai√∫sculas ou min√∫sculas.

Isto significa que estas duas strings: ThisIsTheNameOfTheFile e thisisthenameofthefile descrevem 
dois ficheiros diferentes em sistemas Unix/Linux, mas s√£o o mesmo nome para apenas um ficheiro 
em sistemas Windows.

A principal e mais marcante diferen√ßa √© que tem de usar DOIS SEPARADORES DIFERENTES PARA OS 
NOMES DOS DIRET√ìRIOS: \ no Windows, e / em Unix/Linux.

Esta diferen√ßa n√£o √© muito importante para o utilizador normal, mas √© MUITO IMPORTANTE QUANDO 
SE ESCREVE PROGRAMAS EM PYTHON.

Para entender o porqu√™, tente recordar o papel muito espec√≠fico desempenhado pelo \ dentro de strings Python. 



----------------------------------
Nomes de ficheiros: continua√ß√£o
----------------------------------

Suponha que est√° interessado num ficheiro espec√≠fico localizado na diretoria dir, e nomeado file.

Suponha tamb√©m que pretende atribuir uma string contendo o nome do ficheiro.

Em sistemas Unix/Linux, pode parecer-se com o seguinte:

  ex:
  
    name = "/dir/file"
    
Mas se o tentar codificar para o sistema Windows:

  ex:
  
    name = "\dir\file"
    

ter√° uma surpresa desagrad√°vel: ou o Python ir√° gerar um erro, ou a execu√ß√£o do programa ir√° 
comportar-se de forma estranha, como se o nome do ficheiro tivesse sido distorcido de alguma 
forma.

Na verdade, n√£o √© estranho, mas bastante √≥bvio e natural. O Python usa o \ como um caratere de 
escape (como \n).

Isto significa que os nomes dos ficheiros do Windows devem ser escritos da seguinte forma:

  ex:
  
    name = "\\dir\\file"
    
    
Felizmente, h√° tamb√©m mais uma solu√ß√£o. O Python √© suficientemente inteligente para ser capaz 
de converter barras em barras invertidas, cada vez que descobre que tal √© exigido pelo sistema 
operativo.

Isto significa que quaisquer das seguintes tarefas:

    name = "/dir/file"
    name = "c:/dir/file"
    

funcionar√° com o Windows, tamb√©m.

Qualquer programa escrito em Python (e n√£o s√≥ em Python, porque essa conven√ß√£o se aplica a 
praticamente todas as linguagens de programa√ß√£o) n√£o comunica diretamente com os ficheiros, mas 
atrav√©s de algumas entidades abstratas que s√£o nomeadas de forma diferente em diferentes 
linguagens ou ambientes - os termos mais utilizados s√£o handles ou streams (vamos us√°-los aqui 
como sin√≥nimos).

O programador, tendo um conjunto de fun√ß√µes/m√©todos mais ou menos ricos, √© capaz de realizar 
certas opera√ß√µes no stream, que afetam os ficheiros reais utilizando mecanismos contidos no 
kernel do sistema operativo.

Desta forma, √© poss√≠vel implementar o processo de acesso a qualquer ficheiro, mesmo quando o 
nome do ficheiro √© desconhecido no momento da reda√ß√£o do programa.


As opera√ß√µes realizadas com o stream abstrato refletem as atividades relacionadas com o 
ficheiro f√≠sico.

  - üì¶Ô∏è PCAP: Programming FUndamentals in Python (Part 2)
    |
    |- üì¶Ô∏è Welcome to PCAP (Python 102)
    |
    |- üì¶Ô∏è 4 Intermediate: Part 2
    |   |
    |   |- üì¶Ô∏è 4.1 Using Modules
    |   |- üì¶Ô∏è 4.2 Some useful modules
    |   |- üì¶Ô∏è 4.3 What is a package?
    |   |- üì¶Ô∏è 4.4 Errors - programmer's daily bread
    |   |- üì¶Ô∏è 4.5 The anatomy of exceptions
    |   |- üì¶Ô∏è 4.6 Some of the most useful exceptions
    |   |- üì¶Ô∏è 4.7 Characters and strings vs. computers
    |   |- üì¶Ô∏è 4.8 The nature of strings in Python
    |   |- üì¶Ô∏è 4.9 Strings methods
    |   |- üì¶Ô∏è 4.10 Strings in action
    |   |- üì¶Ô∏è 4.11 Four simple programs
    |   |- üì¶Ô∏è Module 4 Quiz
    |
    |---üì¶Ô∏è 5 Intermediate: Part 2
         |
         |- üì¶Ô∏è 5.1 Basic concept of object programming
         |- üì¶Ô∏è 5.2 A short journey from procedural to object approach
         |- üì¶Ô∏è 5.3 Properties
         |- üì¶Ô∏è 5.4 Methods
         |- üì¶Ô∏è 5.5 Inheritance - one of object programming fondations
         |- üì¶Ô∏è 5.6 Exceptions once again
         |- üì¶Ô∏è 5.7 Generators and closures
         |     -------------------
         |- üì¶Ô∏è| Processing files |  <----- Pasta selecionada
         |     -------------------
         |- üì¶Ô∏è 5.9 Working with real files
         |- üì¶Ô∏è Module 5 Quiz 


Para conectar (vincular) o stream com o ficheiro, √© necess√°rio realizar uma opera√ß√£o expl√≠cita.

A opera√ß√£o de conectar o stream com um ficheiro chama-se ABRIR O FICHEIRO, enquanto que 
desconectar esta liga√ß√£o chama-se FECHAR O FICHEIRO.

Assim, a conclus√£o √© que a primeira opera√ß√£o realizada no stream √© sempre open e a √∫ltima √© 
close. O programa, na verdade, √© livre de manipular o stream entre estes dois eventos e para 
lidar com o ficheiro associado.

Esta liberdade √© limitada, naturalmente, pelas caracter√≠sticas f√≠sicas do ficheiro e pela forma 
como o ficheiro foi aberto.

Digamos novamente que a abertura do stream pode falhar, e pode acontecer devido a v√°rias 
raz√µes: a mais comum √© a falta de um ficheiro com um nome especificado.

Tamb√©m pode acontecer que o ficheiro f√≠sico exista, mas o programa n√£o est√° autorizado a 
abri-lo. H√° tamb√©m o risco de que o programa tenha aberto demasiados streams, e o sistema 
operacional espec√≠fico pode n√£o permitir a abertura simult√¢nea de mais de n ficheiros (por 
exemplo, 200).

Um programa bem escrito deve detetar estas aberturas falhadas, e reagir em conformidade.



----------------------
Stream de ficheiros
----------------------

A abertura do stream n√£o est√° apenas associada ao ficheiro, mas deve tamb√©m declarar a forma 
pela qual o stream ser√° processado. Esta declara√ß√£o √© chamada OPEN MODE (modo aberto).

Se a abertura for bem sucedida, o PROGRAMA SER√Å AUTORIZADO A EXECUTAR APENAS
AS OPERA√á√ïES QUE SEJAM CONSISTENTES COM O OPEN MODE DECLARADO.

H√° duas opera√ß√µes b√°sicas executadas no stream:

    - LER a partir do stream: as por√ß√µes dos dados s√£o recuperadas do ficheiro e colocadas numa 
    √°rea da mem√≥ria gerida pelo programa (por exemplo, uma vari√°vel);

    - ESCREVER para o stream: as por√ß√µes dos dados da mem√≥ria (por exemplo, uma vari√°vel) s√£o 
    transferidas para o ficheiro.


Existem tr√™s modos b√°sicos usados para abrir o stream:

    - READ MODE (modo de leitura): um stream aberto neste modo permite APENAS OPERA√á√ïES DE 
    LEITURA; tentar escrever no stream causar√° uma exce√ß√£o (nomeada UnsupportedOperation, que 
    herda OSError e ValueError, e vem do io m√≥dulo);
    
    - WRITE MODE (modo de escrita): um stream aberto neste modo permite APENAS OPERA√á√ïES DE 
    ESCRITA; tentar ler o stream causar√° a exce√ß√£o mencionada acima;
    
    - UPDATE MODE (modo de atualiza√ß√£o): um stream aberto neste modo permite TANTO ESCRITAS 
    COMO LEITURAS.


Antes de discutirmos como manipular os streams, devemos-lhe algumas explica√ß√µes. O STREAM 
COMPORTA-SE QUASE COMO UM GRAVADOR.

Quando se l√™ algo de um stream, uma cabe√ßa virtual move-se sobre o stream de acordo com o 
n√∫mero de bytes transferidos do stream.

Quando se escreve algo no stream, a mesma cabe√ßa move-se ao longo do stream gravando os dados a 
partir da mem√≥ria.

Sempre que falarmos de ler e escrever para o stream, tente imaginar esta analogia. Os livros de 
programa√ß√£o referem-se a este mecanismo como a CURRENT FILE POSITION (posi√ß√£o atual do 
ficheiro), e tamb√©m utilizaremos este termo.

               --------------
              |  ----------  |
              |  ----------  |
     WRITE    |              |    READ
    ------->  |  HARD DISK   |  ------->
              |              |
              |   /-----\    |
              |   |     |    |
              |   \-----/    |
               --------------
 
Agora √© necess√°rio mostrar-lhe o objeto respons√°vel por representar streams em programas.



---------------------------------
Handles de ficheiro
-----------------------------

O Python assume que CADA FICHEIRO EST√Å ESCONDIDO ATR√ÅS DE UM OBJETO DE UMA CLASSE ADEQUADA.

Claro, √© dif√≠cil n√£o perguntar como interpretar a palavra adequada.

Os ficheiros podem ser processados de v√°rias maneiras - alguns deles dependem do conte√∫do do ficheiro, alguns das inten√ß√µes do programador.

Em qualquer um dos casos, ficheiros diferentes podem exigir diferentes conjuntos de opera√ß√µes, e comportar-se de maneiras diferentes.

Um objeto de uma classe adequada √© CRIADO QUANDO SE ABRE O FICHEIRO E ANIQUILADO 
NO MOMENTO DO ENCERRAMENTO.

Entre estes dois eventos, pode-se usar o objeto para especificar quais as opera√ß√µes que devem 
ser executadas num stream espec√≠fico. As opera√ß√µes que tem permiss√£o para usar s√£o impostas 
pela FORMA COMO ABRIU O FICHEIRO.

Em geral, o objeto vem de uma das classes mostradas aqui:

                      ------------   
                      |  IOBase  |
                      ------------
                      /    |     \
                    /      |       \
                  /        |         \
                /          |           \
              /            |             \   
         RawIOBase   BufferedIOBase   TextIOBase


Nota: nunca se usa construtores para dar vida a estes objetos. A √∫nica forma de os OBTER √â 
INVOCAR A FUN√á√ÉO CHAMADA: open().

A fun√ß√£o analisa os argumentos que forneceu e cria automaticamente o objeto necess√°rio.

Se quiser LIVRAR DO OBJETO, INVOCA-SE O M√âTODO CHAMADO: close().

A invoca√ß√£o ir√° cortar a liga√ß√£o com o objeto e o ficheiro, e remover√° o objeto.

Para os nossos prop√≥sitos, vamos preocupar-nos apenas com fluxos representados por objetos 
BufferIOBase e TextIOBase . Compreender√° porqu√™ em breve.



---------------------------------
Handles de ficheiros: continua√ß√£o
----------------------------------

Devido ao tipo de conte√∫do do stream, TODOS OS STREAMS EST√ÉO DIVIDIDOS EM 
STREAMS DE TEXTO E STREAMS BIN√ÅRIOS.

Os streams de texto s√£o estruturados em linhas; ou seja, cont√™m carateres tipogr√°ficos (letras, d√≠gitos, pontua√ß√£o, etc.) dispostos em filas (linhas), como se v√™ a olho nu quando se olha para o conte√∫do do ficheiro no editor.

Este ficheiro √© escrito (ou lido) na sua maioria, caratere por caratere, ou linha por linha.

Os streams bin√°rios n√£o cont√™m texto mas uma sequ√™ncia de bytes de qualquer valor. Esta 
sequ√™ncia pode ser, por exemplo, um programa execut√°vel, uma imagem, um √°udio ou um videoclipe, 
um ficheiro de base de dados, etc.

Como estes ficheiros n√£o cont√™m linhas, as leituras e escritas referem-se a por√ß√µes de dados de 
qualquer tamanho. Assim, os dados s√£o lidos/escritos byte a byte, ou bloco a bloco, onde o 
tamanho do bloco varia geralmente de um a um valor arbitrariamente escolhido.

Ent√£o aparece um problema subtil. Nos sistemas Unix/Linux, as extremidades das linhas s√£o 
marcadas por um √∫nico caratere chamado LF (c√≥digo ASCII 10) designado nos programas 
Python como: \n.

Outros sistemas operativos, especialmente estes derivados do sistema pr√©-hist√≥rico CP/M (que 
tamb√©m se aplica aos sistemas da fam√≠lia Windows) utilizam uma conven√ß√£o diferente: o fim da 
linha √© marcado por um par de carateres, CR e LF (c√≥digos ASCII 13 e 10) que podem ser 
codificados como: \r\n.

Esta ambiguidade pode causar v√°rias consequ√™ncias desagrad√°veis.

Se criar um programa respons√°vel pelo processamento de um ficheiro de texto, e este for escrito 
para Windows, pode reconhecer as extremidades das linhas ao encontrar os carateres \r\n , mas o 
mesmo programa em execu√ß√£o num ambiente Unix/Linux ser√° completamente in√∫til, e vice-versa: o 
programa escrito para sistemas Unix/Linux poder√° ser in√∫til no Windows.

Estas caracter√≠sticas indesej√°veis do programa, que impedem ou dificultam a utiliza√ß√£o do 
programa em diferentes ambientes, s√£o chamadas N√ÉO-PORTABILIDADE.

Da mesma forma, a caracter√≠stica do programa que permite a execu√ß√£o em diferentes ambientes 
chama-se PORTABILIDADE. Um programa dotado de tal caracter√≠stica √© chamado um PROGRAMA PORT√ÅTIL.



------------------------
Handles de ficheiros: continua√ß√£o
----------------------------------

Uma vez que as quest√µes de portabilidade eram (e ainda s√£o) muito s√©rias, foi tomada a decis√£o 
de resolver definitivamente a quest√£o de uma forma que n√£o atrai a aten√ß√£o do programador.


             ----------          -----------
             |       |  \        |        |  \ 
             |       |___|       |        |___|
             |           |       |            |
             | Text File |       | Music File |
             |           |       |            |
             |           |       |            |
             |           |       |            |
             -------------       -------------


Foi feito ao n√≠vel das classes, que s√£o respons√°veis pela leitura e escrita dos carateres de e 
para o stream. Funciona da seguinte maneira:

  - quando o stream est√° aberto e √© avisado que os dados no ficheiro associado ser√£o 
  processados como texto (ou n√£o existe tal aviso), √© MUDADA PARA O MODO DE TEXTO;

  - durante a leitura/escrita de linhas de/para o ficheiro associado, nada de especial ocorre 
  no ambiente Unix, mas quando as mesmas opera√ß√µes s√£o realizadas no ambiente Windows, ocorre 
  um processo chamado TRADU√á√ÉO DE CARACTERES NEWLINE: quando se l√™ uma linha do ficheiro, cada 
  par de carateres: \r\n √© substitu√≠do por um √∫nico caratere: \n , e vice-versa; durante as 
  opera√ß√µes de escrita, cada caratere: \n √© substitu√≠do por um par de: \r\n carateres;

  - o mecanismo √© completamente TRANSPARENTE para o programa, que pode ser escrito como se 
  fosse destinado a processar apenas ficheiros de texto Unix/Linux; o source code executado num 
  ambiente Windows tamb√©m funcionar√° corretamente;

  - quando o stream est√° aberto e √© aconselhado a faz√™-lo, o seu conte√∫do √© tomado tal como 
  est√°, SEM QUALQUER CONVERS√ÉO - nenhum byte √© adicionado ou omitido.



-----------------------------
Abertura dos streams
-----------------------------

A ABERTURA DE STREAM √© realizada por uma fun√ß√£o que pode ser invocada da seguinte forma:

  ex:
  
    stream = open(file, mode = 'r', encoding = None)


Vamos analis√°-la:

    - o nome da fun√ß√£o (open) fala por si; se a abertura for bem sucedida, a fun√ß√£o devolve um 
    objeto de stream; caso contr√°rio, √© levantada uma exce√ß√£o (por exemplo, FileNotFoundError 
    SE O FICHEIRO QUE VAI LER N√ÉO EXISTIR);

    - o primeiro par√¢metro da fun√ß√£o (file) especifica o nome do ficheiro a ser associado ao 
    stream;

    - o segundo par√¢metro (mode) especifica o modo aberto utilizado para o stream; √© uma string 
    cheia de carateres, e cada um deles tem o seu significado especial (mais detalhes em breve);

    - o terceiro par√¢metro (encoding) especifica o tipo de codifica√ß√£o (por exemplo, UTF-8 
    quando se trabalha com ficheiros de texto)

    - a abertura deve ser a primeira opera√ß√£o realizada no stream.


Nota: o modo e os argumentos de codifica√ß√£o podem ser omitidos - os seus valores por padr√£o 
s√£o ent√£o assumidos. O modo de abertura padr√£o √© a leitura em modo de texto, enquanto que a 
codifica√ß√£o padr√£o depende da plataforma utilizada.

Deixe-nos agora apresentar-lhe os modos abertos mais importantes e √∫teis. Preparado?



-------------------------------
Abrir os streams: modos
-------------------------------

r modo aberto: read

    - o stream ser√° aberto em READ MODE (modo de leitura);
    - o ficheiro associado ao stream TEM DE EXISTIR e tem de ser leg√≠vel, caso contr√°rio a 
    fun√ß√£o open() levanta uma exce√ß√£o.


w modo aberto: write

    - o stream ser√° aberto em WRITE MODE (modo de escrita);
    - o ficheiro associado ao stream N√ÉO PRECISA DE EXISTIR; se n√£o existir, ser√° criado; se 
    existir, ser√° truncado at√© ao comprimento de zero (apagado); se a cria√ß√£o n√£o for poss√≠vel 
    (por exemplo, devido √†s permiss√µes do sistema) a fun√ß√£o open() levanta uma exce√ß√£o.


a modo aberto: append

    - o stream ser√° aberto em APPEND MODE (modo anexo);
    - o ficheiro associado ao stream N√ÉO PRECISA DE EXISTIR; se n√£o existir, ser√° criado; se 
    existir, a cabe√ßa de grava√ß√£o virtual ser√° colocada no fim do ficheiro (o conte√∫do anterior 
    do ficheiro permanece intocado).


r+ modo aberto: read and update

    o stream ser√° aberto em READ AND UPDATE MODE (modo de leitura e atualiza√ß√£o);
    o ficheiro associado ao stream TEM DE EXISTIR E TEM DE SER GRAV√ÅVEL, caso contr√°rio a 
    fun√ß√£o open() levanta uma exce√ß√£o;
    tanto as opera√ß√µes de leitura como de escrita s√£o permitidas para o stream.


w+ modo aberto: write and update

    o stream ser√° aberto em WRITE AND UPDATE MODE (modo de grava√ß√£o e atualiza√ß√£o);
    o ficheiro associado ao stream N√ÉO PRECISA EXISTIR; se n√£o existir, ser√° criado; o conte√∫do 
    anterior do ficheiro permanece intocado;
    tanto as opera√ß√µes de leitura como de escrita s√£o permitidas para o stream.


----------------------------------
Sele√ß√£o de texto e modos bin√°rios
----------------------------------

Se houver uma letra b no final da string de modo significa que o stream deve ser aberto no MODO 
BIN√ÅRIO.

Se a string de modo termina com uma letra t o stream √© aberto no MODO DE TEXTO.

O modo de texto √© o comportamento por padr√£o assumido quando n√£o √© utilizado um especificador 
do modo bin√°rio/texto.

Finalmente, a abertura bem sucedida do ficheiro ir√° definir a posi√ß√£o atual do ficheiro (a 
cabe√ßa de leitura/escrita virtual) antes do primeiro byte do ficheiro, SE O MODO N√ÉO FOR: a e 
ap√≥s o √∫ltimo byte de ficheiro SE O MODO ESTIVER DEFINIDO PARA: a.

               ---------------------------------------------------------------
               |  Modo de Texto        Modo bin√°rio        Descri√ß√£o          |
               |--------------------------------------------------------------|
               |       rt                   rb                read            |
               |                                                              |
               |       wt                   wb                write           |
               |                                                              |
               |       at                   ab                append          |
               |                                                              |
               |       r+t                  r+b           read and update     |
               |                                                              |
               |       w+t                  w+b           write and update    |
               |                                                              |
               ----------------------------------------------------------------

EXTRA

Tamb√©m se pode abrir um ficheiro para a sua cria√ß√£o exclusiva. Pode fazer isto usando o x modo 
aberto. Se o ficheiro j√° existir, a fun√ß√£o open() ir√° levantar uma exce√ß√£o.



-----------------------------------
Abrir o stream pela primeira vez
-----------------------------------

Imagine que queremos desenvolver um programa que leia o conte√∫do do ficheiro de 
texto nomeado: C:\Users\User\Desktop\file.txt.

Como abrir esse ficheiro para leitura? Aqui est√° o snippet relevante do c√≥digo:

  ex:
  
    try:
        stream = open("C:\Users\User\Desktop\file.txt", "rt")
        # Processing goes here.
        stream.close()
    except Exception as exc:
        print("Cannot open the file:", exc)


O que se passa aqui?

    - abrimos o bloco try-except porque queremos lidar suavemente com os erros de runtime;
    
    - utiliz√°mos a fun√ß√£o open() para tentar abrir o ficheiro especificado (note a forma como 
    especific√°mos o nome do ficheiro)
    
    - o modo aberto √© definido como texto a ler (como O TEXTO √â A DEFINI√á√ÉO PADR√ÉO, podemos 
    saltar o t na string de modo)
    
    - em caso de sucesso, obtemos um objeto da fun√ß√£o open() e atribu√≠mo-lo √† vari√°vel de 
    stream;
    
    - Se open() falhar, tratamos da exce√ß√£o imprimindo a informa√ß√£o de erro completa (√© bom 
    saber o que aconteceu exatamente)



----------------------------
Streams pr√©-abertos
----------------------------

Dissemos anteriormente que qualquer opera√ß√£o de stream deve ser precedida pela open() invoca√ß√£o 
de fun√ß√£o. Existem tr√™s exce√ß√µes bem definidas √† regra.

Quando o nosso programa come√ßa, os tr√™s streams j√° est√£o abertos e n√£o requerem quaisquer 
prepara√ß√µes extra. Al√©m disso, o seu programa pode utilizar estes streams explicitamente se 
tiver o cuidado de importar o m√≥dulo sys :

    import sys


porque √© a√≠ que a declara√ß√£o dos tr√™s streams √© colocada.


Os nomes desses streams s√£o: sys.stdin, sys.stdout, e sys.stderr.


Vamos analis√°-los:

    - sys.stdin
        - stdin (de standard input)
        - o stream stdin √© normalmente associado ao teclado, pr√©-aberto para leitura e 
        considerado como a principal fonte de dados para os programas em execu√ß√£o;
        - a bem conhecida fun√ß√£o input() l√™ dados de stdin por padr√£o.

    - sys.stdout
        - stdout (de standard output)
        - o stream stdout √© normalmente associado ao ecr√£, pr√©-aberto para escrita, considerado 
        como o alvo principal para o output de dados pelo programa em execu√ß√£o;
        - a bem conhecida fun√ß√£o print() faz output dos dados para o stream stdout .

    - sys.stderr
        - stderr (de standard error output)
        - o stream stderr √© normalmente associado ao ecr√£, pr√©-aberto para escrita, considerado 
        como o local principal onde o programa em execu√ß√£o deve enviar informa√ß√µes sobre os 
        erros encontrados durante o seu trabalho;
        - n√£o apresent√°mos nenhum m√©todo para enviar os dados para este stream (f√°-lo-emos em 
        breve, prometemos)
        - a separa√ß√£o de stdout (resultados √∫teis produzidos pelo programa) a partir de stderr 
        (mensagens de erro, inegavelmente √∫teis mas que n√£o fornecem resultados) d√° a 
        possibilidade de redirecionar estes dois tipos de informa√ß√£o para os diferentes alvos. 
        Uma discuss√£o mais alargada sobre esta quest√£o est√° para al√©m do √¢mbito do nosso curso. 
        O manual do sistema de funcionamento fornecer√° mais informa√ß√µes sobre estas quest√µes.



----------------------
Fechar streams
----------------------

A √∫ltima opera√ß√£o executada num stream (n√£o inclui streams stdin, stdout, e stderr que n√£o o 
exijam) deve estar A FECHAR.

Essa a√ß√£o √© executada por um m√©todo invocado de dentro do objeto de stream aberto: 
stream.close().

    - o nome da fun√ß√£o definitivamente comenta-se a si pr√≥prio: close()
    - a fun√ß√£o n√£o espera exatamente nenhum argumento; o stream n√£o precisa de ser aberto
    - a fun√ß√£o n√£o devolve nada, mas levanta a exce√ß√£o IOError em caso de erro;
    - a maioria dos programadores acreditam que a fun√ß√£o close() √© sempre bem sucedida e, 
    portanto, n√£o h√° necessidade de verificar se cumpriu devidamente a sua tarefa.

    Esta cren√ßa √© apenas parcialmente justificada. Se o stream foi aberto para escrita e, em 
    seguida, uma s√©rie de opera√ß√µes de escrita foram executadas, pode acontecer que os dados 
    enviados para o stream ainda n√£o tenham sido transferidos para o dispositivo f√≠sico (devido 
    a um mecanismo chamado CACHING ou BUFFERING).

    Uma vez que o fecho do stream for√ßa os buffers a lhes fazer flush, pode ser que os flushes 
    falhem e, portanto, a close() falha tamb√©m.


J√° mencion√°mos falhas causadas por fun√ß√µes que operam com streams, mas n√£o mencion√°mos uma 
palavra sobre como podemos identificar exatamente a causa da falha.

A possibilidade de fazer um diagn√≥stico existe e √© fornecida por um componente de exce√ß√£o dos 
streams de que vamos falar agora.



----------------------------------
Diagnosticar problemas de stream
----------------------------------

O objeto IOError est√° equipado com uma propriedade chamada errno (o nome vem da frase error 
number) e pode aced√™-lo da seguinte forma:

  ex:
  
    try:
        # Some stream operations.
    except IOError as exc:
        print(exc.errno)
        
        
O valor do atributo errno pode ser comparado com uma das constantes simb√≥licas predefinidas, 
definidas no m√≥dulo errno .

Vamos dar uma vista de olhos a algumas CONSTANTES √öTEIS PARA DETECTAR ERROS DE STREAM:

    - errno.EACCES ‚Üí Permission denied

        O erro ocorre quando tenta, por exemplo, abrir um ficheiro com o atributo read only 
        para escrita.


    - errno.EBADF ‚Üí Bad file number

        O erro ocorre quando tenta, por exemplo, operar com um stream n√£o aberto.


    - errno.EEXIST ‚Üí File exists

        O erro ocorre quando tenta, por exemplo, renomear um ficheiro com o seu nome anterior.


    - errno.EFBIG ‚Üí File too large

        O erro ocorre quando tenta criar um ficheiro maior do que o m√°ximo permitido pelo 
        sistema operativo.


    - errno.EISDIR ‚Üí Is a directory

        O erro ocorre quando tenta tratar um nome de diretoria como o nome de um ficheiro comum.


    - errno.EMFILE ‚Üí Too many open files

        O erro ocorre quando tenta abrir simultaneamente mais streams do que os aceit√°veis para 
        o seu sistema operativo.

    - errno.ENOENT ‚Üí No such file or directory

        O erro ocorre quando tenta aceder a um ficheiro/diretoria inexistente.

    - errno.ENOSPC ‚Üí No space left on device

        O erro ocorre quando n√£o h√° espa√ßo livre na media.

A lista completa √© muito mais longa (inclui tamb√©m alguns c√≥digos de erro n√£o relacionados ao 
processamento de stream.)



-----------------------------------------------
Diagnosticar problemas de stream: continua√ß√£o
-----------------------------------------------

Se voc√™ for programador muito cuidadoso, poder√° sentir a necessidade de utilizar a sequ√™ncia de 
afirma√ß√µes semelhante √†s apresentadas no 

  ex:
  
    import errno

    try:
        s = open("c:/users/user/Desktop/file.txt", "rt")
        # Actual processing goes here.
        s.close()
    except Exception as exc:
        if exc.errno == errno.ENOENT:
        print("The file doesn't exist.")
        elif exc.errno == errno.EMFILE:
            print("You've opened too many files.")
        else:
            print("The error number is:", exc.errno)


Felizmente, existe uma fun√ß√£o que pode drasticamente SIMPLIFICAR O C√ìDIGO DE TRATAMENTO DE 
ERROS.

O seu nome √© strerror(), e vem do m√≥dulo os e ESPERA APENAS UM ARGUMENTO - UM N√öMERO DE ERRO.

O seu papel √© simples: d√°-se um n√∫mero de erro e obt√©m-se uma string descrevendo o significado 
do erro.

  Nota: se passar um c√≥digo de erro inexistente (um n√∫mero que n√£o est√° vinculado a nenhum erro 
  real), a fun√ß√£o ir√° levantar uma exce√ß√£o ValueError .

Agora podemos simplificar o nosso c√≥digo da seguinte forma:

  ex:

    from os import strerror

    try:
        s = open("c:/users/user/Desktop/file.txt", "rt")
        # Actual processing goes here.
        s.close()
    except Exception as exc:
        print("The file could not be opened:", strerror(exc.errno))


Okay. Agora √© altura de lidar com ficheiros de texto e familiarizar-se com algumas t√©cnicas 
b√°sicas que pode utilizar para os processar.



---------------------------
Resumo da sess√£o
---------------------------

1. Um ficheiro tem de estar ABERTO antes de poder ser processado por um programa, e deve estar 
FECHADO quando o processamento estiver terminado.

A abertura do ficheiro associa-o ao STREAM, que √© uma representa√ß√£o abstrata dos dados f√≠sicos 
armazenados na media. A forma como o stream √© processado √© chamada MODO ABERTO. Existem TR√äS 
modos abertos:

    MODO DE LEITURA ‚Äî apenas s√£o permitidas opera√ß√µes de leitura;
    MODO DE ESCRITA ‚Äî apenas s√£o permitidas opera√ß√µes de escrita;
    MODO DE UPDATE ‚Äî tanto as escritas como as leituras s√£o permitidas.


2. Dependendo do conte√∫do do ficheiro f√≠sico, diferentes classes de Python podem ser utilizadas 
para processar ficheiros. Em geral, o BufferedIOBase √© capaz de processar qualquer ficheiro, 
enquanto TextIOBase √© uma classe especializada dedicada ao processamento de ficheiros de texto 
(ou seja, ficheiros contendo textos vis√≠veis para humanos, divididos em linhas utilizando 
marcadores de nova linha). Assim, os streams podem ser divididos em BIN√ÅRIOS e de TEXTO.


3. A seguinte sintaxe da fun√ß√£o open() √© utilizada para abrir um ficheiro:

open(file_name, mode=open_mode, encoding=text_encoding)

A invoca√ß√£o cria um objeto de fluxo e associa-o ao ficheiro com o nome file_name, usando o 
especificado open_mode e definindo o especificado text_encoding, ou LEVANTA UMA EXCESS√ÉO
NO CASO DE UM ERRO..


4. Tr√™s streams PREDEFINIDOS j√° est√£o abertos quando o programa √© iniciado:

    - sys.stdin ‚Äî standard input;
    - sys.stdout ‚Äî standard output;
    - sys.stderr ‚Äî standard error output.


5. O objeto da exce√ß√£o IOError , criado quando qualquer opera√ß√£o de ficheiro falha (incluindo 
opera√ß√µes abertas), cont√©m uma propriedade chamada errno, que cont√©m o c√≥digo de conclus√£o da 
a√ß√£o falhada. Use este valor para diagnosticar o problema.






































